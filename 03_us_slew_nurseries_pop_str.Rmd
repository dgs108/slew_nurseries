---
title: "Great Hammerheads, Population Structure"
output: 
  html_notebook: 
    highlight: kate
    theme: flatly
    toc: yes
  html_document: 
    toc: yes
---

Assess population structure using `Arlequin`, PCA, and DAPC.

# Environment
  
```{r, message=FALSE}

.libPaths("/usr/lib64/R/library")

# invalidate cache when the package version changes

knitr::opts_chunk$set(
  root.dir = "~/projects/hammerheads/great",
	message = FALSE,
	warning = FALSE,
  cache.extra = packageVersion("tint"),
	tidy = FALSE,
	echo = FALSE)

options(htmltools.dir.version = FALSE)

# conflicts

library(conflicted)
conflict_prefer("count", "dplyr")
conflict_prefer("arrange", "dplyr")
conflict_prefer("mutate", "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
conflict_prefer("rename", "dplyr")
conflict_prefer("summarise", "dplyr")
conflict_prefer("summarize", "dplyr")
conflict_prefer("s.label", "adegraphics")
conflict_prefer("s.value", "adegraphics")
conflict_prefer("scalebar", "raster")
conflict_prefer("rename", "dplyr")
conflict_prefer("extract", "raster")
conflict_prefer("degree", "igraph")

# packages

library(tidyverse)
library(adegenet)
library(ggthemes)
library(tufte)
library(tint)
library(knitr)
library(gdata)
library(zvau)
library(patchwork)
library(here)
library(readxl)

# source scripts

source("~/bin/ggplot.R")
source("~/bin/genind.R")
source("~/bin/PCA.R")
source("~/bin/DAPC.R")
source("~/bin/vegan.R")
source("~/bin/ordiR2step.R")

# orders, colors, shapes

nursery_order <- c("BB", "TR", "CB", "FPH", "CCB")

nursery_order_full <- c("Bulls Bay", "Tolomator River", "Cape Canaveral", "Florida Panhandle", "Corpus Christi Bay")

nursery_map <- rlang::set_names(nursery_order_full, nursery_order)

nursery_colors <- c('#a50026', '#f46d43', '#fee090', '#74add1', '#313695')

```

# Produce Files

Convert `.gen` to `.arp`.

```{bash, eval=FALSE}

conda activate great_hh

cd /home/dswift/projects/hammerheads/nurseries/data/

# fdist

PGDSpider2-cli -inputfile ../results/slew_no_sibs.gen -inputformat GENEPOP -outputfile pop_str/slew_no_sibs.arp -outputformat ARLEQUIN -spid ~/bin/genepop_arl_SNPs.spid

rm PGDSpider-cli.log

ls pop_str/slew_no_sibs.arp | while read i; do sed -i 's/"pop_1"/"BB"/g' $i $i; sed -i 's/"pop_2"/"TR"/g' $i $i; sed -i 's/"pop_3"/"CB"/g' $i $i ; sed -i 's/"pop_4"/"FPH"/g' $i $i; sed -i 's/"pop_5"/"CCB"/g' $i $i; done
 
```

# Arlequin

## AMOVA

Execute AMOVA via GUI.

## Pairwise FST Locus-by-Locus

Produce structure files for each pair of regions using a list of regions and `produce_str_files.sh`

```{bash}

BB
TR
CB
FPH
CCB

```
```{bash}

#!/bin/bash

# Input file and output directory
GROUP_FILE="/home/dswift/projects/hammerheads/nurseries/data/pop_str/slew_nurseries.txt"
OUTDIR="/home/dswift/projects/hammerheads/nurseries/data/pop_str/lbl/str_files"

# Create output directory
mkdir -p "$OUTDIR"

# Read groups into an array
mapfile -t groups < "$GROUP_FILE"

# Generate all pairwise combinations
for ((i = 0; i < ${#groups[@]}; i++)); do
  for ((j = i + 1; j < ${#groups[@]}; j++)); do
    g1="${groups[i]}"
    g2="${groups[j]}"
    fname="${OUTDIR}/${g1}_${g2}.txt"

    cat > "$fname" <<EOF
[[Structure]]

StructureName="${g1} + ${g2}"
NbGroups=1

Group={
	"${g1}"
	"${g2}"
}
EOF
  done
done

```

Estimate pairwise FST locus-by-locus.

```{bash}

#!/bin/bash

# ========== CONFIGURATION ==========
BASE_DIR="/home/dswift/projects/hammerheads/nurseries/data/pop_str/lbl"
STR_DIR="$BASE_DIR/str_files"
INPUT_ARP_DIR="$BASE_DIR/.."  # ARP input files are one directory up
ARP_DIR="$BASE_DIR/arp_files"
OUTPUT_DIR="$BASE_DIR/output"
ARS_FILE="$BASE_DIR/slew_nurseries_lbl_pwfst.ars"
CSV_FILE="$BASE_DIR/lbl_pwfst_all_results.csv"

# ========== SETUP ==========
cd "$BASE_DIR" || exit 1

echo "Setting up directories..."
rm -rf "$ARP_DIR" "$OUTPUT_DIR"
mkdir -p "$ARP_DIR"
mkdir -p "$OUTPUT_DIR"

echo "Cleaning up old temporary files..."
rm -f arl_run.* randseed.txt
rm -f *.xml

# ========== COMBINE STRUCTURE + ARP FILES ==========
echo "Combining structure and ARP files..."

structure_files=($STR_DIR/*.txt)
# input .arp file
arp_files=($INPUT_ARP_DIR/slew_no_sibs.arp)

for str in "${structure_files[@]}"; do
  str_base=$(basename "$str" .txt)
  echo "Processing structure: $str_base"

  for arp in "${arp_files[@]}"; do
    arp_base=$(basename "$arp" .arp)

    # Skip any arp files accidentally named with str_files prefix
    if [[ "$arp_base" == str_files* ]]; then
      echo "⚠️ Skipping misnamed ARP file: $arp_base"
      continue
    fi

    new_arp="${str_base}_${arp_base}.arp"
    out_path="$ARP_DIR/$new_arp"

    echo "  + Writing: $out_path"

    # Replace Title and remove old [[Structure]] block
    awk -v newtitle="${str_base}_${arp_base}" '
      BEGIN { skip = 0 }
      /^\s*Title\s*=\s*/ {
        print "  Title = \"" newtitle "\""
        next
      }
      /^\s*\[\[Structure\]\]/ { skip = 1; next }
      skip && /^\s*Group\s*=\s*{/ { next }
      skip && /^\s*}/ { skip = 0; next }
      skip { next }
      { print }
    ' "$arp" > tmp_arp.txt

    # Append the updated structure definition
    cat tmp_arp.txt "$str" > "$out_path"
    rm tmp_arp.txt
  done
done

# ========== RUN ARLECORE ==========
echo "Running arlecore on ARP files..."

for combined_arp in "$ARP_DIR"/*.arp; do
  echo "  > Running on: $(basename "$combined_arp")"
  arlecore "$combined_arp" "$ARS_FILE"
done

# ========== MOVE .res DIRECTORIES TO OUTPUT ==========
echo "Moving .res directories to output..."

for res_dir in "$ARP_DIR"/*.res; do
  if [ -d "$res_dir" ]; then
    mv "$res_dir" "$OUTPUT_DIR/"
  fi
done

# ========== EXTRACT FST VALUES TO CSV (MATCHING .XLSX STRUCTURE) ==========
echo "Extracting FST results to: $CSV_FILE"

printf "structure_file,arp_file,pop1,pop2,FST,pval\n" > "$CSV_FILE"

for xml in "$OUTPUT_DIR"/*.res/*.xml; do
  base_name=$(basename "$xml" .xml)

  # Split structure_file and arp_file
  structure_file=$(echo "$base_name" | cut -d_ -f1)
  arp_file=$(echo "$base_name" | cut -d_ -f2-)

  # Extract pop1 and pop2 from structure_file (e.g., cuba_bahamas)
  pop1=$(echo "$structure_file" | cut -d_ -f1)
  pop2=$(echo "$structure_file" | cut -d_ -f2)

  # FST
  fst=$(grep -m 1 "FST :" "$xml" | awk -F':' '{gsub(/ /, "", $2); print $2}')

  # p-value
  pval=$(grep -m 1 "Va and FST : P(rand. value > obs. value)" "$xml" | awk -F'= ' '{print $2}')

  printf "%s,%s,%s,%s,%s,%s\n" "$structure_file" "$arp_file" "$pop1" "$pop2" "$fst" "$pval" >> "$CSV_FILE"
done

echo "✅ All steps complete. CSV written to $CSV_FILE"

```

### Results

Locus by locus pairwise FST results.

```{r}

# import xlsx

mat <- read_xlsx(here("data", "pop_str", "slew_nurseries_pop_str.xlsx"), sheet = 2, na = c("-", ""))

# nursery order

labs <- mat$X

long <- mat %>%
  rename(row = X) %>%
  pivot_longer(-row, names_to = "col", values_to = "value") %>%
  mutate(
    value = as.numeric(value),
    row = factor(row, levels = labs),
    col = factor(col, levels = labs),
    i = as.integer(row),
    j = as.integer(col)
  )

# p values

pval <- long %>%
  filter(j >= i) %>%
  transmute(
    pair = paste(as.character(row), as.character(col), sep = "-"),
    order_i = i, order_j = j,
    pval = if_else(j > i, value, NA_real_),
    diag_flag = i == j
  )

# fst values

fst <- long %>%
  filter(j < i) %>%
  transmute(
    pair = paste(as.character(col), as.character(row), sep = "-"),
    fst = value
  )

# combine

lbl_pwfst_pvals <- pval %>%
  left_join(fst, by = "pair") %>%
  mutate(
    pval = if_else(diag_flag, NA_real_, pval)
  ) %>%
  arrange(order_i, order_j) %>%
  select(pair, fst, pval) %>% 
  mutate(pval_adj = p.adjust(pval, method = "BH")) %>% 
  mutate(across(2:4, ~ round(as.numeric(.x), 5))) %>% 
  write_csv(., here("data", "pop_str", "slew_nurseries_pwfst_padj.csv"))

```

# Packages

Packages used in this analysis. 

```{r}

subset(data.frame(sessioninfo::package_info()), attached==TRUE, c(package, loadedversion))

```
